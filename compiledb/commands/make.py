import click
import os
import tempfile

from subprocess import call, PIPE, Popen
from sys import exit, stdout, stderr, version_info

from compiledb import generate


if version_info[0] >= 3:  # Python 3
    def popen(cmd, encoding='utf-8', **kwargs):
        return Popen(cmd, encoding=encoding, **kwargs)
else:  # Python 2
    def popen(cmd, encoding='utf-8', **kwargs):
        return Popen(cmd, **kwargs)


class AutoconfMock:
    """This hack is intended to make it possible/feasible
    to use "make --dry-run --always-make" to speed up the compilation
    commands extraction with autoconf/automake based build systems.
    Without this ugly hack, particularly `--always-make` causes the
    autoconf's configure script to be executed to every make target,
    severely slowing down the process.
    To work around this issue we use a mock/empty script to be used
    in place of config.status and missing is they exist.
    """
    def __init__(self, verbose):
        self.verbose = verbose
        self.config_path = 'config.status'
        self.missing_path = 'missing'
        self.config_bkp = "bkp_{}".format(self.config_path)
        self.missing_bkp = "bkp_{}".format(self.missing_path)
        self.tmp_script = None

    def __enter__(self):
        has_config = os.path.isfile(self.config_path)
        has_missing = os.path.isfile(self.missing_path)
        if not has_config and not has_missing:
            return self
        try:
            fd, tmp = tempfile.mkstemp()
            with os.fdopen(fd, 'w') as out:
                out.write('#/bin/sh')
                out.write('# Automatically generated by compiledb. Do not modify!')

            self.tmp_script = tmp
            if has_config:
                os.rename(self.config_path, self.config_bkp)
                os.symlink(self.tmp_script, self.config_path)
            if has_missing:
                os.rename(self.missing_path, self.missing_bkp)
                os.symlink(self.tmp_script, self.missing_path)
        except Exception as e:
            self.cleanup()
            raise e

    def __exit__(self, exc_type, exc_value, traceback):
        self.cleanup()

    def cleanup(self):
        if self.verbose:
            print("Cleaning up autoconf mock resources..")

        if os.path.isfile(self.config_bkp):
            os.rename(self.config_bkp, self.config_path)

        if os.path.isfile(self.missing_bkp):
            os.rename(self.missing_bkp, self.missing_path)

        if os.path.isfile(self.tmp_script):
            os.remove(self.tmp_script)


@click.command(name='make', context_settings=dict(ignore_unknown_options=True))
@click.option('-c', '--cmd', 'make_cmd', nargs=1, required=False,
              help="Command to be used as make executable.")
@click.argument('make_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def command(ctx, make_cmd, make_args):
    """Generates compilation database file for an arbitrary GNU Make command.
     Acts like a make wrapper, forwarding all MAKE_ARGS to make command"""
    make_cmd = make_cmd or 'make'
    logging_mode_flags = "-Bnkw"

    options = ctx.obj

    if not options.no_build:
        cmd = [make_cmd] + list(make_args)
        print("## Building [{}]...".format(' '.join(cmd)))
        ret = call(cmd, stdout=stdout, stderr=stderr)
        print()
        if ret != 0:
            exit(1)

    done = False
    args = vars(options)
    del args['no_build']
    with AutoconfMock(options.verbose):
        cmd = [make_cmd, logging_mode_flags] + list(make_args)
        pipe = popen(cmd, stdout=PIPE, stderr=PIPE, encoding='utf-8')
        options.infile = pipe.stdout
        done = generate(**args)
        pipe.wait()
    exit(0 if done else 1)
